## JSX
JSX is javascript sugar for react. It is recommended being used in React to describe what the UI should look like.
JSX may remind you of template languate, but **it comes with the full power of javascript** <br>
JSX produces React 'element'. <br>

### Embedding Expressions in JSX
```javascript
const name = 'Josh'
const element = <h1>Hello, {name}</h1>
ReactDOM.render(
  element,
  document.getElementById('app')
)
```
You can put any valid JavaScript expression inside the curly braces in JSX.<br>

### JS is an Expression Too

### Specifying Attributes with JSX

### Specifying Children with JSX
JSX tag may contain children:
```javascript
const element = (
  <div>
    <h1> Hello</h1>
    <h2> Good to see you here</h2>
  </div>
)
```

### JSX Represents Objects
Babel compiles JSX down to React.createElement() calls.<br>

These two are indentical:
```javascript
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
)
```

```javascript
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
)
```


## Rendering an Element into the DOM
```javascript
import ReactDOM from 'react-dom'
const ele = <h1>Hello, world<h1>
ReactDOM.render(ele, document.getElementById('root'))
```


## Components and Props
### Functional and class Components
The simplest way to define a component is to write a JavaScript function:<br>
```javascript
function Welcome (props) {
  return (
    <h1> Hello, {props.name}</h1>
  )
}
```
This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions.<br>

You can also use an **ES6 class** to define a component:
```javascript
class Welcome extends React.Component {
  render () {
    return <h1> Hello, {this.props.name}</h1>
  }
}
```
The above two components are equivalent from React’s point of view.<br>

### Rendering a Component
```javascript
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
)
```
The render method will be called each time an update happen.

### Composing Components

### Extracting Components
** DRY ** principle for create a component. <br>

### Props are Read-Only
Consider this *sum* function:
```javascript
function sum (a, b) {
  return a + b
}
```
Such functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs.<br>

In contrast, this function is impure because it changes its own input:
```javascript
function withdraw (account, amount) {
  account.amount -= amount
}
```

React is pretty flexible but it has a single strict rule:
**All React components must act like pure functions with respect to their props.*


## State and Lifecycle
State is similar to props, but it is private and fully controlled by the component.<br>

The differences bettween a pure function component and a **ES6** class component is that a function component doest not have state. <br>

```javascript
import React, { Component } from 'react'
import './index.scss'

class Tick extends Component {
  // Class components should always call the base constructor with props.
  constructor(props) {
    super(props)
    this.state = {
      date: new Date()
    }
  }
  // render function returns an instance of React class
  render () {
    return (
      <div className="Tick">
        <h1>Hello, world!</h1>
        <h2>It's {this.state.date.toLocaleTimeString()}</h2>
      </div>
    )
  }
}

export default Tick
```

### Adding Lifecycle Methods to a Class
The **componentDidMount()** hook runs after the component output has been rendered to the DOM.<br>

In react, we use **this.setState()** to update a local state for a component.<br>

If the a component is ever removed from the DOM, React calls the **componentWillUnmount()** lifecycle hook so the timer is stopped.

### Using State Correctly

#### Update state by **setState**

#### State Updates May Be Asynchronous
React may batch multiple setState() calls into a single update for performance.<br>

Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.<br>

Solution:
```javascript
this.setState((prevState, props) => ({
  counter: prevState.counter + props.increment
}));
```
**setState** function accepts a function rather than an object.

### State Updates are Merged

### The Data Flows Down
This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree. <br>


