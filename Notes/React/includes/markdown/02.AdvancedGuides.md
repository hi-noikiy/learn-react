# Advanced Guides

## 1. Accessibility

React fully supports building accessible websites, often by using standard HTML techniques.

## 2. Code-Splitting

### 2.1 import

Before:

```javascript
import { add } from './math';

console.log(add(16, 26));
```

After:

```javascript
import("./math").then(math => {
  console.log(math.add(16, 26))
});
```

### 2.2 Using **react-loadable**

- 2.2.1 **react-loadable**

Before:

```javascript
import OtherComponent from './OtherComponent';

const MyComponent = () => (
  <OtherComponent/>
)
```

After:

```javascript
import Loadable from 'react-loadable';

const LoadableOtherComponent = Loadable({
  loader: () => import('./OtherComponent'),
  loading: () => <div>Loading...</div>,
})

const MyComponent = () => (
  <LoadableOtherComponent/>
)
```

- 2.2.2 Spliting code by Route

```javascript
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Loadable from 'react-loadable';

const Loading = () => <div>Loading...</div>;

const Home = Loadable({
  loader: () => import('./routes/Home'),
  loading: Loading,
});

const About = Loadable({
  loader: () => import('./routes/About'),
  loading: Loading,
});

const App = () => (
  <Router>
    <Switch>
      <Route exact path="/" component={Home}/>
      <Route path="/about" component={About}/>
    </Switch>
  </Router>
)
```

**React Loadable helps you create loading states, error states, timeouts, preloading, and more. It can even help you server-side render an app with lots of code-splitting.**

More information about **react-loadable**, please go to [https://github.com/jamiebuilds/react-loadable](https://github.com/jamiebuilds/react-loadable)

## 3. Context

**Context provides a way to pass data through the component tree without having to pass props down manually at every level. It is designed to share data that can be considered "global" for a tree of React components.**

In the following example, we need to pass props from the top(ToolBar) to child(ThemedButton) and child's child(Button), which is cumbersome.

```javascript
class App extends React.Component {
  render () {
    return <ToolBar theme="dark"/>
  }

  function ToolBar(props) {
    <div>
      <ThemedButton them={props.theme} />
    </div>
  }

  function ThemedButton(props) {
    return <Button theme={props.theme} />
  }
}
```

By using **Context**, we can avoid passing props through intermediate elements:

```javascript
const ThemeContext = React.createContext('light');

class App extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  )
}

function ThemedButton(props) {
  return (
    <ThemeContext.Consumer>
      {theme => <Button {...props} theme={theme} />}
    </ThemeContext.Consumer>
  );
}
```

### 3.1 When to Use Context

### 3.1.1 Before You Use Context

**Context** is primarily used when some data needs to be accessible by many components at different nesting levels. Apply it sparingly because it makes component reuse more diffcult.

**If you only want to avoid passing some props through many levels, the component composition is often a simpler solution than context**.

### 3.2 API of **Context**

#### 3.2.1 React.createContext

```javascript
const { Provider, Consumer } = React.CreateContext(defaultValue)
```

```javascript
<Provider value={'some value'}></Provider>
```

The **Provider** accepts a *value* prop to be passed to Consumers that are descendants of it.

```javascript
<Consumer>
  {
    value => {
      // do something with the value accepted from Provider of it.
    }
  }
</Consumer>
```

### 3.3 Consuming Context with a Hoc

### 3.4 Forwarding Refs to Context Consumers

## 4. Error Boundaries

### 4.1 Note

**Error boundaries do not catch errors for:**

- Event handlers (learn more)
- Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)
- Server side rendering
- Errors thrown in the error boundary itself (rather than its children)
- A javascript error in a part of UI shouldn't break the whole app. To solve this problem for React users, React 16 introduces a new concept of an **"error boundary"**.

Error boundaries are React concepts that **catch javascript errors anywhere in their child component tree, log errors, and display a fallback UI** instead of the component tree that crashed. **Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.**.

A class component becomes an error boundary if it defines a new lifecycle method called **componentDidCatch(error, info)**

A sample of error boundary:

```javascript
import React from 'react'

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      hasError: false
    }
  }

  componentDidCatch(error, info) {
    this.setState({
      hasError: true
    })

    // you can aslo log the error to an error reporting service
    logErrorToMyService(error, info)
  }

  render() {
    if(this.state.hasError) {
      return <h1>Somthing went wrong</h1>
    }
    return this.props.children
  }
}
```

Use it

```javascript
<ErrorBoundary>  
  <MyWidget />
</ErrorBoundary>
```

A full example, please go to [https://codepen.io/gaearon/pen/wqvxGa?editors=0010](https://codepen.io/gaearon/pen/wqvxGa?editors=0010)

### 4.2 New Behavior for Uncaught Errors

**As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.**

## 5. Optimizing Performance

- Use the Production Build

## Portals

### API for Portals

```javascript
import ReactDOM from 'react-dom'

ReactDOM.createPortal(child, container)
```

### Usage

A typical use case for portals is when a parent component has an overflow: hidden or z-index style, but you need the child to visually “break out” of its container. For example, dialogs, hovercards, and tooltips.

### Event Bubbling Through Portals

## Typechecking with PropTypes

### Type checking

```javascript
import PropTypes from 'prop-types'
class MyComponent extends React.Component {
  render() {
    // This must be exactly one element or it will warn.
    const children = this.props.children;
    return (
      <div>
        {children}
      </div>
    );
  }
}

MyComponent.propTypes = {
  children: PropTypes.element.isRequired
}
```

### Default Prop Values

```javascript
class Greeting extends React.Component {
  render() {
    return (
      <h1>Hello, {this.props.name}</h1>
    );
  }
}

Greeting.defaultProps = {
  name: 'Stranger'
}

ReactDOM.render(
  <Greeting />,
  document.getElementById('example')
)
```

For the demo of propTypes above, we can write it in the following form as well:

```javascript
class Greeting extends React.Component {
  static propTypes = {}
  static defaultTypes = {}
  render() {
    return (
      <h1>Hello, {this.props.name}</h1>
    );
  }
}
```

## React Component design pattern

Two ways for component reusing in **React** programming.

### A function used as a child component

*MyComponent*'s definetion:

```javascript
class MyComponent extends React.Component {
  render () {
    return (
      <div>
        {this.props.children('A function used as cihld component')}
      </div>
    )
  }
}
```

Usage of **MyComponent**

```javascript
<MyComponent>
  {
    (name) => (
      <p className="author-desc">{name}</p>
    )
  }
</MyComponent>
```

In the above example, the children of *MyComponent* is a function but not a React Component.

The parent component determines how to utilize the props passed from parent Component.

A detailed demo and explanation please go to [https://time.geekbang.org/course/detail/100-9442](https://time.geekbang.org/course/detail/100-9442)

### Hight Order Component

Concretely, **a higher-order component is a function that takes a component and returns a new component.**

Passing a function as **props.children** for a component enable we can control the child component in the place we use it.

```javascript
const EnhancedComponent = higherOrderComponent(WrappedComponent)
```

A component passes props into UI, a higher-order component transforms a component into another component.

HOC component provides business logic to a child component, it should not have UI properties by default.

A detailed demo and explanation, please go to [https://time.geekbang.org/course/detail/100-9442](https://time.geekbang.org/course/detail/100-9442)

## API reference

### Overview

## Refs and the DOM

**Refs provide a way to access DOM nodes or React elements created in the render method.**

### When to Use Refs

Avoid using refs for anything that can be done declaratively.

For example, instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it.

### Create a Ref

```javascript
class MyForm extends React.Component {
  constructor (props) {
    super(props)
    this.emailInput = React.createRef()
  }

  render () {
    return (
      <div>
        <input type="text" name="email" ref={this.emailInput}/>
      </div>
    )
  }
}
```

### Access Ref

```javascript
const node = this.myRef.current
```
